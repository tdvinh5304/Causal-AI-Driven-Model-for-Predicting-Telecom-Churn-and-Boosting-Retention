# -*- coding: utf-8 -*-
"""An enhanced model for predicting customer churn rates and improving retention using Causal AI in the telecom.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wK6KtBMw4Djmg58C5jFrjXoGub8wwD1c

# Telco Customer Churn Classification
"""

!gdown 1-QItPjherVspbnHb86UxGv3ohtWX9RqV

"""**Vấn đề:**
Trong ngành viễn thông, nơi khách hàng có nhiều lựa chọn giữa các nhà cung cấp dịch vụ liên lạc và internet, thách thức lớn nằm ở việc giữ chân khách hàng. Chất lượng dịch vụ ảnh hưởng đáng kể đến cảm nhận của khách hàng, khi ngay cả một sự cố bảo trì ngắn cũng có thể gây lo lắng, qua đó làm nổi bật sự phụ thuộc mà chúng ta thường bỏ qua vào các dịch vụ này. Cùng với chi phí cao để thu hút khách hàng mới, việc phân tích tỷ lệ rời bỏ trở nên rất quan trọng. Tỷ lệ rời bỏ, thể hiện qua việc khách hàng hủy đăng ký, có tác động trực tiếp đến doanh thu. Những hiểu biết từ phân tích rời bỏ giúp các công ty xây dựng các chiến lược nhắm mục tiêu cụ thể, cải thiện chất lượng dịch vụ và xây dựng lòng tin của khách hàng. Việc xây dựng các mô hình dự đoán và tạo ra các báo cáo phân tích rời bỏ toàn diện là rất cần thiết cho sự phát triển bền vững của doanh nghiệp.

# Mục tiêu :
Mục tiêu trước mắt là phân loại các khách hàng có khả năng rời bỏ bằng cách tận dụng cả các đặc trưng số và đặc trưng phân loại. Điều này bao gồm việc giải quyết một bài toán phân loại nhị phân trong bối cảnh bộ dữ liệu có sự mất cân đối.

## Các thuộc tính của bộ dữ liệu

Bộ dữ liệu bao gồm nhiều thuộc tính đa dạng, cung cấp những thông tin giá trị về chi tiết và tương tác của khách hàng. Các thông tin cụ thể liên quan đến từng khách hàng bao gồm mã định danh duy nhất (customerID), thông tin về giới tính, và một chỉ báo nhị phân xác định liệu khách hàng có thuộc nhóm người cao tuổi (SeniorCitizen) hay không.

Ngoài ra, các thuộc tính còn ghi nhận các khía cạnh quan hệ như việc khách hàng có bạn đời (Partner) và người phụ thuộc (Dependents) hay không. Thuộc tính tenure biểu thị thời gian (tính bằng tháng) mà khách hàng đã gắn bó với công ty.

Các dịch vụ liên lạc được đại diện bởi các thuộc tính như PhoneService và MultipleLines, cho biết sự hiện diện của dịch vụ điện thoại và liệu khách hàng có sử dụng nhiều đường dây hay không. Các tính năng liên quan đến internet bao gồm nhà cung cấp dịch vụ internet (InternetService), bảo mật trực tuyến (OnlineSecurity), sao lưu trực tuyến (OnlineBackup), bảo vệ thiết bị (DeviceProtection), và hỗ trợ kỹ thuật (TechSupport).

Các dịch vụ giải trí được phản ánh thông qua các thuộc tính như truyền hình trực tuyến (StreamingTV) và phim trực tuyến (StreamingMovies). Thuộc tính Contract thể hiện thời hạn hợp đồng của khách hàng, với các lựa chọn như hợp đồng hàng tháng, hợp đồng một năm và hai năm.

Các tùy chọn thanh toán được trình bày qua thuộc tính PaperlessBilling, chỉ ra liệu khách hàng có chọn hình thức thanh toán không cần hóa đơn giấy hay không. Thuộc tính PaymentMethod chỉ định cách thức khách hàng thanh toán, với các lựa chọn như electronic check, mailed check, bank transfer (automatic), and credit card (automatic)..

Các chi tiết tài chính bao gồm MonthlyCharges (phí hàng tháng) mà khách hàng phải trả và TotalCharges (tổng chi phí) mà họ đã tích lũy.

Cuối cùng, thuộc tính quan trọng Churn cho biết liệu khách hàng đã rời bỏ hay chưa, đóng vai trò then chốt trong việc hiểu rõ các động lực giữ chân khách hàng.

### Các thư viện được sử dụng

Để tiến hành phân tích, chúng ta cần nhập các thư viện cần thiết. Những thư viện này cung cấp các công cụ và chức năng quan trọng để xử lý, trực quan hóa và phân tích bộ dữ liệu một cách hiệu quả. Các thư viện sau đây sẽ được nhập để phục vụ mục đích này.
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
pd.options.display.float_format = '{:.2f}'.format
import warnings
warnings.filterwarnings('ignore')
!pip install dowhy
from dowhy import CausalModel
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import PolynomialFeatures
from sklearn.ensemble import GradientBoostingClassifier
from xgboost import XGBClassifier
import imblearn
from collections import Counter
from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from sklearn.impute import SimpleImputer
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import accuracy_score, classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import roc_curve, auc
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score
import xgboost as xgb
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
import random
!pip install jinja2==2.11.3 markupsafe==2.0.1 eli5==0.11 scikit-learn==1.1.3
import eli5
from eli5.sklearn import PermutationImportance
from sklearn import tree
import graphviz
from sklearn.tree import DecisionTreeClassifier

data = pd.read_csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')
data.head()

data.info()

# Convert the column to float
data['SeniorCitizen'] = data['SeniorCitizen'] = data['SeniorCitizen'].astype(object)
data['TotalCharges'] = pd.to_numeric(data['TotalCharges'], errors='coerce')

data.info()

data.columns

data.isnull().sum()

data['TotalCharges'].replace(" ", np.nan, inplace=True)
# Fill NaN values in TotalCharges with corresponding values from MonthlyCharges
data['TotalCharges'].fillna(data['MonthlyCharges'], inplace=True)
data.drop(columns = ['customerID'], inplace = True)

data.isnull().sum()

data.describe()

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()

df1 = data.copy(deep = True)
text_data_features = [i for i in list(data.columns) if i not in list(data.describe().columns)]

print('Label Encoder Transformation')
for i in text_data_features :
    df1[i] = le.fit_transform(df1[i])
    print(i,' : ',df1[i].unique(),' = ',le.inverse_transform(df1[i].unique()))

"""Nhóm sẽ tạo một bản sao sâu của bộ dữ liệu gốc để đảm bảo rằng các thay đổi được thực hiện trong quá trình mã hóa nhãn sẽ không ảnh hưởng đến bộ dữ liệu ban đầu. Bản sao sâu này sẽ đóng vai trò là phiên bản mà tất cả các đặc trưng đã được chuyển đổi thành giá trị số, giúp thuận tiện hơn cho việc trực quan hóa và xây dựng mô hình.

Sau đó, nhóm sẽ tính toán lại các thống kê mô tả của dữ liệu để cung cấp một cái nhìn tổng quan toàn diện về bộ dữ liệu sau khi đã được chuyển đổi.
"""

#from google.colab import drive
#drive.mount('/content/gdrive')
#x=pd.DataFrame(df1)
#x.to_excel(excel_writer=r'/content/gdrive/MyDrive/Data_processed.xlsx')

colors = ['#E94B3C','#2D2926']

churn = df1[df1['Churn'] == 1].describe().T
not_churn = df1[df1['Churn'] == 0].describe().T

fig,ax = plt.subplots(nrows = 1,ncols = 2,figsize = (5,5))
plt.subplot(1,2,1)
sns.heatmap(churn[['mean']],annot = True,cmap = colors,linewidths = 0.4,linecolor = 'black',cbar = False,fmt = '.2f')
plt.title('Churned Customers');

plt.subplot(1,2,2)
sns.heatmap(not_churn[['mean']],annot = True,cmap = colors,linewidths = 0.4,linecolor = 'black',cbar = False,fmt = '.2f',)
plt.title('Not_Churned Customers');

fig.tight_layout(pad = 0)

"""- Thời gian gắn bó trung bình (Mean Tenure): Khách hàng rời bỏ có thời gian gắn bó trung bình thấp hơn (17,98 tháng) so với những khách hàng tiếp tục sử dụng dịch vụ (37,57 tháng).

- Online Services: Các tính năng như OnlineSecurity, OnlineBackup, DeviceProtection, và TechSupport có giá trị trung bình cao hơn ở nhóm khách hàng không rời bỏ, cho thấy vai trò tiềm năng của các dịch vụ này trong việc giữ chân khách hàng.

- Thời hạn hợp đồng: Hợp đồng của khách hàng rời bỏ thường ngắn hơn đáng kể so với hợp đồng của khách hàng không rời bỏ.

- Chi phí hàng tháng (Monthly Charges): Chi phí hàng tháng trung bình của khách hàng rời bỏ (74,44) cao hơn so với khách hàng không rời bỏ (61,27).

- Tổng chi phí (Total Charges): Khách hàng không rời bỏ có tổng chi phí trung bình cao hơn (2555,34) so với khách hàng rời bỏ (1531,80).

- Các đặc trưng phân loại (Categorical Features): Do có nhiều đặc trưng phân loại, giá trị trung bình của chúng tập trung quanh mức 0.

Những phát hiện này làm nổi bật các yếu tố cần tập trung để giữ chân khách hàng, đồng thời nhấn mạnh tầm quan trọng của các đặc trưng cụ thể trong việc ảnh hưởng đến tình trạng rời bỏ của khách hàng. Phần phân tích khám phá dữ liệu (EDA) sẽ cung cấp cái nhìn chi tiết hơn về những đặc trưng này.

# Exploratory Data Analysis (EDA)
"""

#Dividing features into Numerical and Categorical :

col = list(df1.columns)
categorical_features = []
numerical_features = []
for i in col:
    if len(df1[i].unique()) > 6:
        numerical_features.append(i)
    else:
        categorical_features.append(i)

print('Categorical Features :',*categorical_features)
print('Numerical Features :',*numerical_features)

"""Trong bối cảnh phân tích này, các đặc trưng được phân loại là đặc trưng phân loại (categorical) nếu chúng có ít hơn 6 giá trị duy nhất; ngược lại, chúng được coi là đặc trưng số (numerical). Mặc dù một phương pháp khác là sử dụng kiểu dữ liệu của các phần tử (ví dụ: kiểu số nguyên cho đặc trưng số và chuỗi ký tự cho đặc trưng phân loại), với kích thước bộ dữ liệu nhỏ gọn, việc kiểm tra thủ công cũng có thể thực hiện được.

Cách tiếp cận kép này đảm bảo việc phân loại đặc trưng thành đặc trưng số và phân loại được thực hiện chính xác, tạo điều kiện để hiểu rõ bản chất của chúng và hỗ trợ các bước phân tích tiếp theo một cách hiệu quả.

# Trực Quan Hóa Biến Mục Tiêu Churn

Hiểu rõ sự phân phối của biến mục tiêu "Churn" là rất quan trọng để có cái nhìn sâu sắc về hành vi của khách hàng. Trong trực quan hóa này:

- Phân phối Churn: Chúng ta khám phá sự phân phối giữa khách hàng đã rời bỏ và khách hàng không rời bỏ để đánh giá sự mất cân đối trong bộ dữ liệu.

- Biểu diễn trực quan: Sử dụng đồ thị hoặc biểu đồ để trình bày một cách rõ ràng và súc tích tỷ lệ khách hàng đã rời bỏ và những khách hàng không rời bỏ.

- Thông tin chi tiết: Phân tích các mô hình trong sự phân phối churn có thể giúp phát hiện các thách thức và cơ hội trong việc giải quyết vấn đề giữ chân khách hàng.

Trực quan hóa này đóng vai trò là bước nền tảng trong việc hiểu biến mục tiêu của bộ dữ liệu, tạo tiền đề cho các phân tích và xây dựng mô hình sâu hơn.
"""

colors = ['#E94B3C','#00FFFF']
# Assuming 'Churn' is a categorical variable with values 'Yes' and 'No'

l = list(df1['Churn'].value_counts())
circle = [l[0] / sum(l) * 100, l[1] / sum(l) * 100]

# Create subplots
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(20, 5))

# Pie chart
axes[0].pie(circle, labels=['Not-Churn Customer', 'Churn Customer'], autopct='%1.1f%%', startangle=90, explode=(0.1, 0),
            colors=colors, wedgeprops={'edgecolor': 'black', 'linewidth': 1, 'antialiased': True})
axes[0].set_title('Churn - Not-Churn %')

# Countplot
ax = sns.countplot(x='Churn', data=df1, palette=colors, edgecolor='black')
for rect in ax.patches:
    ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(),
            horizontalalignment='center', fontsize=11)
ax.set_xticklabels(['Not-Churn Customers', 'Churn Customers'])

ax.set_title('Number of Churn - Not-Churn Customers')

plt.show()

"""Bộ dữ liệu có sự phân phối mất cân đối, với tỷ lệ khoảng 3:1 giữa khách hàng không rời bỏ (Not-Churn) và khách hàng rời bỏ (Churn). Sự mất cân đối này gây ra sự thiên lệch trong các dự đoán, khi mà mô hình có thể nghiêng về việc dự đoán chính xác các trường hợp không rời bỏ.

Các trực quan hóa sẽ minh họa rõ ràng sự chênh lệch này, làm nổi bật thách thức mà sự phân phối lệch lạc trong bộ dữ liệu mang lại. Việc giải quyết sự mất cân đối giữa các lớp sẽ là yếu tố quan trọng trong các bước xây dựng mô hình tiếp theo để đảm bảo kết quả dự đoán chính xác và có ý nghĩa hơn.

## Các Đặc Trưng Phân Loại và Ảnh Hưởng Của Chúng Đến Biến Mục Tiêu (Churn)
"""

categorical_features.remove('Churn')

"""Vì mục đích trực quan hóa, chúng ta sẽ loại trừ biến mục tiêu "Churn" khỏi danh sách các đặc trưng phân loại. Điều này giúp tập trung vào việc xem xét cách các đặc trưng phân loại khác ảnh hưởng đến khả năng khách hàng rời bỏ."""

l1 = ['gender','SeniorCitizen','Partner','Dependents'] # Customer Information
l2 = ['PhoneService','MultipleLines','InternetService','StreamingTV','StreamingMovies',
      'OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport'] # Services Signed Up for!
l3 = ['Contract','PaperlessBilling','PaymentMethod'] # Payment Information

"""Để quản lý sự phong phú của các đặc trưng phân loại trong bộ dữ liệu, chúng ta phân loại chúng thành ba nhóm dựa trên giá trị hoặc tên cột của chúng. Việc phân loại này giúp tổ chức và phân tích các đặc trưng một cách hiệu quả hơn, tạo điều kiện cho việc khám phá có cấu trúc về tác động của chúng đối với biến mục tiêu.

## Nhóm 1: Thông tin khách hàng

Danh mục này bao gồm các thuộc tính liên quan đến nhân khẩu học và đặc điểm của khách hàng:
- **Gender**
- **SeniorCitizen**
- **Partner**
- **Dependents**
"""

fig = plt.subplots(nrows = 2,ncols = 2,figsize = (20,14))
for i in range(len(l1)):
    plt.subplot(2,2,i+1)
    ax = sns.countplot(x=l1[i],data = df1,hue = "Churn",palette = colors,edgecolor = 'black')
    for rect in ax.patches:
        ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
    title = l1[i] + ' vs Churn'
    plt.title(title);

"""- **Gender Churn Analysis:**
  Tỷ lệ churn giữa khách hàng nam và nữ khá tương đồng, cho thấy sự tương tự trong hành vi rời bỏ giữa các giới.

- **SeniorCitizen Analysis:**
  Số lượng khách hàng là người cao tuổi (SeniorCitizen) tương đối thấp. Tuy nhiên, trong số các khách hàng này, khoảng 40% đã rời bỏ, chiếm 476 trong tổng số 1142 khách hàng là người cao tuổi.

- **Partner Status Impact:**
  Khách hàng sống cùng bạn đời có tỷ lệ churn thấp hơn so với những khách hàng không có bạn đời.

- **Dependents Influence:**
  Tỷ lệ churn cao hơn đối với những khách hàng không có người phụ thuộc, cho thấy khả năng có sự tương quan giữa tình trạng gia đình và việc giữ chân khách hàng.

Những quan sát này cung cấp cái nhìn về các phân khúc khách hàng cụ thể có thể cần các chiến lược giữ chân nhắm mục tiêu. Hiểu được hành vi chi tiết trong các nhóm này có thể giúp phát triển các phương pháp tiếp cận phù hợp hơn để giữ chân khách hàng.

## Nhóm 2: Dịch Vụ Khách Hàng Đăng Ký
Vì mục đích trực quan hóa, chúng ta sẽ phân loại các đặc trưng liên quan đến các dịch vụ mà khách hàng đã đăng ký thành hai nhóm:

- **PhoneService**
- **MultipleLines**
- **InternetService**
- **StreamingTV**
- **StreamingMovies**

Việc phân nhóm này giúp tập trung vào việc nghiên cứu hành vi của khách hàng dựa trên các dịch vụ mà họ đã đăng ký, hỗ trợ việc nhận diện các mẫu hình và xu hướng trong các đặc trưng liên quan đến dịch vụ này.
"""

fig = plt.subplots(nrows = 1,ncols = 2,figsize = (12,5))

for i in range(len(l2[0:2])):
    plt.subplot(1,2,i + 1)
    ax = sns.countplot(x=l2[i],data = df1,hue = "Churn",palette = colors,edgecolor = 'black')
    for rect in ax.patches:
        ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
    title = l2[i] + ' vs Churn'
    plt.title(title);

fig = plt.subplots(nrows = 1, ncols = 1, figsize = (6,5))

plt.subplot(1,1,1)
ax = sns.countplot(x=l2[2],data = df1,hue = "Churn",palette = colors,edgecolor = 'black')
for rect in ax.patches:
    ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
title = l2[2] + ' vs Churn'
plt.title(title);

fig = plt.subplots(nrows = 1,ncols = 2,figsize = (12,5))

for i in range(len(l2[3:5])):
    plt.subplot(1,2,i + 1)
    ax = sns.countplot(x=l2[i + 2],data = df1,hue = "Churn",palette = colors,edgecolor = 'black')
    for rect in ax.patches:
        ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
    title = l2[i + 3] + ' vs Churn'
    plt.title(title)

"""- **PhoneService Analysis:**
  Đặc biệt, tỷ lệ giữ chân khách hàng cao hơn đối với những khách hàng không sử dụng dịch vụ điện thoại so với những khách hàng đã chọn ngừng sử dụng dịch vụ.

- **MultipleLines Impact:**
  Tỷ lệ churn có vẻ ổn định bất kể khách hàng có đăng ký nhiều đường dây hay không.

- **InternetService Preferences:**
  Một số lượng đáng kể khách hàng có xu hướng không sử dụng cáp quang (Fiber optic) cho dịch vụ Internet. Ngược lại, dữ liệu cho thấy khách hàng có xu hướng sử dụng DSL nhiều hơn.

- **Insights on Streaming Services:**
  Cả StreamingTV và StreamingMovies đều thể hiện các mẫu hình churn tương tự. Dù có đăng ký hay không, một số lượng đáng kể khách hàng đã rời bỏ. Điều này cho thấy rằng có những yếu tố ngoài việc cung cấp nội dung streaming mà góp phần vào sự không hài lòng của khách hàng.

Những quan sát này làm sáng tỏ hành vi của khách hàng liên quan đến các dịch vụ họ sử dụng, cung cấp những thông tin giá trị để xây dựng các chiến lược nhắm mục tiêu nhằm cải thiện việc giữ chân khách hàng.

### Nhóm 2: Dịch Vụ Khách Hàng Đăng Ký

Danh mục này bao gồm các đặc trưng liên quan đến các dịch vụ bảo mật và hỗ trợ mà khách hàng đã đăng ký:

- **OnlineSecurity**
- **OnlineBackup**
- **DeviceProtection**
- **TechSupport**

Khám phá các thuộc tính này sẽ cung cấp cái nhìn về cách khách hàng tương tác với các dịch vụ bảo mật và hỗ trợ, từ đó hướng dẫn phát triển các chiến lược nhằm nâng cao sự hài lòng và giữ chân khách hàng.
"""

fig = plt.subplots(nrows = 2,ncols = 2,figsize = (20,14))
for i in range(len(l2[-4:])):
    plt.subplot(2,2,i + 1)
    ax = sns.countplot(x=l2[-4 + i],data = df1,hue = "Churn",palette = colors,edgecolor = 'black')
    for rect in ax.patches:
        ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
    title = l2[-4 + i] + ' vs Churn'
    plt.title(title);

"""Các trực quan hóa chỉ ra tầm quan trọng quan trọng của các dịch vụ liên quan đến OnlineSecurity, OnlineBackup, DeviceProtection, và TechSupport trong việc giữ chân khách hàng. Một số lượng đáng kể khách hàng đã chọn chuyển nhà cung cấp dịch vụ, nhấn mạnh sự quan trọng của việc cung cấp các dịch vụ vững mạnh và hài lòng trong những lĩnh vực này. Những phát hiện này nhấn mạnh sự cần thiết phải có nỗ lực tập trung vào việc cải thiện và quảng bá các dịch vụ này để nâng cao sự hài lòng và giữ chân khách hàng tổng thể.

### Group 3

Nhóm này bao gồm các đặc trưng liên quan đến các điều khoản hợp đồng, sở thích thanh toán và phương thức thanh toán:

- **Contract**
- **PaperlessBilling**
- **PaymentMethod**

Phân tích các đặc trưng này sẽ cung cấp cái nhìn về sở thích của khách hàng đối với cam kết hợp đồng, quy trình thanh toán và phương thức thanh toán, từ đó hướng dẫn các chiến lược tối ưu hóa sự hài lòng và giữ chân khách hàng.
"""

fig = plt.subplots(nrows = 1,ncols = 3,figsize = (25,7))

plt.subplot(1,3,1)
ax = sns.countplot(x=l3[0],data = df1,hue = "Churn",palette = colors,edgecolor = 'black')
for rect in ax.patches:
    ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
title = l3[0] + ' vs Churn'
plt.title(title);

plt.subplot(1,3,2)
ax = sns.countplot(x=l3[1],data = df1,hue = "Churn",palette = colors,edgecolor = 'black')
for rect in ax.patches:
    ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
title = l3[1] + ' vs Churn'
plt.title(title);

plt.subplot(1,3,3)
ax = sns.countplot(x=l3[2],data = df1,hue = "Churn",palette = colors,edgecolor = 'black')
for rect in ax.patches:
     ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
title = l3[2] + ' vs Churn'
plt.title(title);

"""- **Contract Analysis:**
  Tỷ lệ churn của khách hàng đối với các hợp đồng theo hình thức Month-to-Month khá cao. Điều này có thể do khách hàng thử nghiệm các dịch vụ khác nhau và chọn các cam kết ngắn hạn để khám phá các tùy chọn có sẵn hoặc tiết kiệm chi phí.

- **PaperlessBilling Impact:**
  Một số lượng đáng kể khách hàng rời bỏ khi sử dụng PaperlessBilling, gợi ý có thể có các vấn đề liên quan đến quy trình thanh toán hoặc nhận hóa đơn.

- **PaymentMethod Insights:**
  Khách hàng thể hiện sự không ưa thích mạnh mẽ đối với phương thức thanh toán bằng Electronic check. Trong số 2365 hóa đơn được thanh toán qua Electronic check, có tới 1071 khách hàng đã chọn ngừng sử dụng dịch vụ. Việc giải quyết các vấn đề với Electronic check hoặc xem xét lại việc sử dụng phương thức này có thể cần thiết để nâng cao sự hài lòng của khách hàng.

Những quan sát này nhấn mạnh tầm quan trọng của việc hiểu sở thích của khách hàng trong các điều khoản hợp đồng, phương thức thanh toán và quy trình thanh toán. Việc triển khai các biện pháp để giải quyết các điểm khó khăn cụ thể có thể đóng góp đáng kể vào nỗ lực giữ chân khách hàng.

### Phân Tích Các Đặc Trưng Phân Loại Liên Quan Đến Các Trường Hợp Churn

Cuộc điều tra này tập trung vào việc xem xét tác động của các đặc trưng phân loại đặc biệt đối với những khách hàng đã trải qua churn. Mục tiêu là nhận diện các mẫu hình, mối tương quan và các yếu tố ảnh hưởng giữa các đặc trưng phân loại này trong bối cảnh các trường hợp churn. Những phát hiện từ phân tích này sẽ cung cấp những thông tin giá trị để tối ưu hóa các chiến lược nhằm giữ chân khách hàng.

### Nhóm 1: Thông Tin Khách Hàng

Trong nhóm này, chúng ta khám phá mối quan hệ giữa thông tin khách hàng và các trường hợp churn, tập trung vào các đặc trưng phân loại sau:

- **Gender**
- **SeniorCitizen**
- **Partner**
- **Dependents**

Mục tiêu của phân tích này là khám phá các mẫu hình và mối liên hệ trong những thuộc tính khách hàng cụ thể này liên quan đến các trường hợp churn.
"""

gender = df1[df1['Churn'] == 1]['gender'].value_counts()
gender = [gender[0] / sum(gender) * 100, gender[1] / sum(gender) * 100] # Female / Male

seniorcitizen = df1[df1['Churn'] == 1]['SeniorCitizen'].value_counts()
seniorcitizen = [seniorcitizen[0] / sum(seniorcitizen) * 100,seniorcitizen[1] / sum(seniorcitizen) * 100] # No - Yes

partner = df1[df1['Churn'] == 1]['Partner'].value_counts()
partner = [partner[0] / sum(partner) * 100,partner[1] / sum(partner) * 100] # No - Yes

dependents = df1[df1['Churn'] == 1]['Dependents'].value_counts()
dependents = [dependents[0] / sum(dependents) * 100,dependents[1] / sum(dependents) * 100] # No - Yes

ax,fig = plt.subplots(nrows = 1,ncols = 4,figsize = (15,15))

plt.subplot(1,4,1)
plt.pie(gender,labels = ['Female','Male'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('Gender');

plt.subplot(1,4,2)
plt.pie(seniorcitizen,labels = ['No', 'Yes'],autopct='%1.1f%%',startangle = 90,explode = (0,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('SeniorCitizen');

plt.subplot(1,4,3)
plt.pie(partner,labels = ['No','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('Partner');

plt.subplot(1,4,4)
plt.pie(dependents,labels = ['No','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('Dependents');

"""- **Gender Analysis:**
  Một sự phân chia rõ ràng 50% - 50% được quan sát giữa khách hàng nam và nữ đã chuyển dịch vụ. Điều này cho thấy lý do chuyển dịch vụ có thể liên quan đến chất lượng dịch vụ hoặc các quy trình cụ thể đã gây ra phản ứng tiêu cực từ phía khách hàng.

- **SeniorCitizen Impact:**
  Một tỷ lệ lớn 75% khách hàng churn không được phân loại là SeniorCitizens. Điều này làm nổi bật một lĩnh vực quan trọng mà công ty cần tập trung sự chú ý để phát triển các chiến lược giữ chân khách hàng.

- **Living Arrangements Influence:**
  Khách hàng sống độc lập, không có bạn đời hoặc người phụ thuộc, có xu hướng ngừng sử dụng dịch vụ rõ rệt. Dữ liệu chỉ ra rằng, trung bình, 73,4% khách hàng đã churn sống độc lập.

Những thông tin này cung cấp cái nhìn chi tiết về cách các thuộc tính thông tin khách hàng cụ thể liên quan đến các trường hợp churn. Việc giải quyết những yếu tố này có thể đóng góp đáng kể vào việc phát triển các sáng kiến giữ chân khách hàng hiệu quả.

### Nhóm 2: Dịch Vụ Khách Hàng Đăng Ký

Trong nhóm này, chúng ta sẽ điều tra mối quan hệ giữa các dịch vụ mà khách hàng đã đăng ký và các trường hợp churn. Tập trung vào các đặc trưng phân loại sau:

- **PhoneService**
- **MultipleLines**
- **InternetService**
- **StreamingTV**
- **StreamingMovies**

Mục tiêu của phân tích này là khám phá các mẫu hình và mối tương quan trong các đặc trưng liên quan đến dịch vụ này đối với các trường hợp churn của khách hàng.
"""

phoneservice = df1[df1['Churn'] == 1]['PhoneService'].value_counts()
phoneservice = [phoneservice[0] / sum(phoneservice) * 100, phoneservice[1] / sum(phoneservice) * 100] # No - Yes

multiplelines = df1[df1['Churn'] == 1]['MultipleLines'].value_counts()
multiplelines = [multiplelines[0] / sum(multiplelines) * 100,multiplelines[1] / sum(multiplelines) * 100, multiplelines[2] / sum(multiplelines) * 100] # No - No Phone Service - Yes

internetservice = df1[df1['Churn'] == 1]['InternetService'].value_counts()
internetservice = [internetservice[0] / sum(internetservice) * 100,internetservice[1] / sum(internetservice) * 100, internetservice[2] / sum(internetservice) * 100] # DSL - Fiber Optic - No

streamingtv = df1[df1['Churn'] == 1]['StreamingTV'].value_counts()
streamingtv = [streamingtv[0] / sum(streamingtv) * 100,streamingtv[1] / sum(streamingtv) * 100, streamingtv[2] / sum(streamingtv) * 100] # No - No Internet Service - Yes

streamingmovies = df1[df1['Churn'] == 1]['StreamingMovies'].value_counts()
streamingmovies = [streamingmovies[0] / sum(streamingmovies) * 100,streamingmovies[1] / sum(streamingmovies) * 100, streamingmovies[2] / sum(streamingmovies) * 100] # No - No Internet Service - Yes

colors = ['#E94B3C','#00FFFF' , '#FFFF00' ]
ax,fig = plt.subplots(nrows = 1,ncols = 2,figsize = (8,8))

plt.subplot(1,2,1)
plt.pie(phoneservice,labels = ['No', 'Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('PhoneService');

plt.subplot(1,2,2)
plt.pie(multiplelines,labels = ['No','No Phone Service','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('MultipleLines');

ax,fig = plt.subplots(nrows = 1,ncols = 3,figsize = (12,12))

plt.subplot(1,3,1)
plt.pie(internetservice,labels = ['DSL', 'Fiber Optic','No'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('InternetService');

plt.subplot(1,3,2)
plt.pie(streamingtv,labels = ['No', 'No Internet Service','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('StreamingTV');

plt.subplot(1,3,3)
plt.pie(streamingmovies,labels = ['No', 'No Internet Service','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('StreamingMovies');

"""- **PhoneService Impact:**
  Mặc dù dịch vụ PhoneService được cung cấp, một tỷ lệ đáng kể khách hàng đã chuyển dịch vụ, cho thấy sự không hài lòng hoặc các vấn đề khác liên quan đến dịch vụ.

- **MultipleLines Influence:**
  Việc cung cấp dịch vụ MultipleLines không ảnh hưởng nhiều đến việc khách hàng hủy đăng ký, chỉ ra rằng dịch vụ này có tác động hạn chế đến churn.

- **InternetService Preferences:**
  Một tỷ lệ đáng kể 70% khách hàng đã hủy dịch vụ liên quan đến cáp quang (Fiber Optic) cho InternetService, cho thấy sự ưa chuộng mạnh mẽ đối với các công nghệ khác ngoài cáp quang.

- **Streaming Services Insights:**
  Trong khi những khách hàng không sử dụng dịch vụ StreamingTV và StreamingMovies có xu hướng hủy đăng ký, trung bình có 43,7% khách hàng sử dụng các dịch vụ này đã chuyển dịch vụ. Điều này gợi ý rằng các yếu tố ngoài nội dung streaming cũng góp phần vào việc churn của khách hàng.

### Nhóm 2: Dịch Vụ Khách Hàng Đăng Ký
Trong nhóm này, chúng ta sẽ điều tra mối quan hệ giữa các dịch vụ bảo mật và hỗ trợ mà khách hàng đã đăng ký và các trường hợp churn. Tập trung vào các đặc trưng phân loại sau:

- **OnlineSecurity**
- **OnlineBackup**
- **DeviceProtection**
- **TechSupport**

Mục tiêu của phân tích này là khám phá các mẫu hình và mối tương quan trong các đặc trưng liên quan đến dịch vụ bảo mật và hỗ trợ này đối với các trường hợp churn của khách hàng.
"""

onlinesecurity = df1[df1['Churn'] == 1]['OnlineSecurity'].value_counts()
onlinesecurity = [onlinesecurity[0] / sum(onlinesecurity) * 100,onlinesecurity[1] / sum(onlinesecurity) * 100, onlinesecurity[2] / sum(onlinesecurity) * 100] # No - No Internet Service - Yes

onlinebackup = df1[df1['Churn'] == 1]['OnlineBackup'].value_counts()
onlinebackup = [onlinebackup[0] / sum(onlinebackup) * 100,onlinebackup[1] / sum(onlinebackup) * 100, onlinebackup[2] / sum(onlinebackup) * 100] # No - No Internet Service - Yes

deviceprotection = df1[df1['Churn'] == 1]['DeviceProtection'].value_counts()
deviceprotection = [deviceprotection[0] / sum(deviceprotection) * 100,deviceprotection[1] / sum(deviceprotection) * 100, deviceprotection[2] / sum(deviceprotection) * 100] # No - No Internet Service - Yes

techsupport = df1[df1['Churn'] == 1]['TechSupport'].value_counts()
techsupport = [techsupport[0] / sum(techsupport) * 100,techsupport[1] / sum(techsupport) * 100, techsupport[2] / sum(techsupport) * 100] # No - No Internet Service - Yes

colors = ['#E94B3C','#00FFFF' , '#FFFF00' ]
ax,fig = plt.subplots(nrows = 1,ncols = 4,figsize = (15,15))

plt.subplot(1,4,1)
plt.pie(onlinesecurity,labels = ['No', 'No Internet Service','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('OnlineSecurity');

plt.subplot(1,4,2)
plt.pie(onlinebackup,labels = ['No', 'No Internet Service','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0.1,0),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('OnlineBackup');

plt.subplot(1,4,3)
plt.pie(deviceprotection,labels = ['No', 'No Internet Service','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('DeviceProtection');

plt.subplot(1,4,4)
plt.pie(techsupport,labels = ['No', 'No Internet Service','Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('TechSupport');

"""Các biểu đồ tròn trên làm nổi bật tầm quan trọng then chốt của việc cung cấp các dịch vụ OnlineSecurity, OnlineBackup, DeviceProtection và TechSupport. Trung bình, 71,6% khách hàng đã ngừng sử dụng dịch vụ do thiếu các tính năng thiết yếu này. Điều này chỉ ra mối tương quan rõ ràng giữa việc cung cấp các dịch vụ bảo mật và hỗ trợ mạnh mẽ với việc giữ chân khách hàng, nhấn mạnh sự cần thiết phải cải thiện chiến lược trong các lĩnh vực này.

### Nhóm 3

Nhóm này tìm hiểu mối quan hệ giữa các điều khoản hợp đồng, sở thích thanh toán và phương thức thanh toán mà khách hàng chọn, đặc biệt trong bối cảnh các trường hợp churn. Các đặc trưng phân loại được xem xét là:

- **Contract**
- **PaperlessBilling**
- **PaymentMethod**

Phân tích các thuộc tính này nhằm mục đích phát hiện các mẫu hình và mối tương quan trong các đặc trưng liên quan đến hợp đồng và dịch vụ tài chính này đối với các trường hợp churn của khách hàng.
"""

contract = df1[df1['Churn'] == 1]['Contract'].value_counts()
contract = [contract[0] / sum(contract) * 100, contract[1] / sum(contract) * 100, contract[2] / sum(contract) * 100] # Month-to-month - One year - Two year

paperlessbilling = df1[df1['Churn'] == 1]['PaperlessBilling'].value_counts()
paperlessbilling = [paperlessbilling[0] / sum(paperlessbilling) * 100,paperlessbilling[1] / sum(paperlessbilling) * 100] # No - Yes

paymentmethod = df1[df1['Churn'] == 1]['PaymentMethod'].value_counts()
paymentmethod = [paymentmethod[0] / sum(paymentmethod) * 100, paymentmethod[1] / sum(paymentmethod) * 100,
            paymentmethod[2] / sum(paymentmethod) * 100, paymentmethod[3] / sum(paymentmethod) * 100]
            # Bank Transfer (automatic) - Credit Card (automatic) - Electronic check - Mailed check

colors = ['#E94B3C','#00FFFF' , '#FFFF00' ]
ax,fig = plt.subplots(nrows = 1,ncols = 3,figsize = (12,12))

plt.subplot(1,3,1)
plt.pie(contract,labels = ['Month-to-month','One year','Two year'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0.1,0.1),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('Contract');

plt.subplot(1,3,2)
plt.pie(paperlessbilling,labels = ['No', 'Yes'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('PaperlessBilling');

plt.subplot(1,3,3)
plt.pie(paymentmethod,labels = ['Bank Transfer (automatic)','Credit Card (automatic)','Electronic check','Mailed check'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0,0.1,0),colors = colors,
       wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('PaymentMethod');

"""- **Contract Duration Impact:**
  Các hợp đồng theo tháng chiếm ưu thế trong việc churn của khách hàng, với tỷ lệ lên tới 88,6%. Điều này làm nổi bật sự cần thiết phải khám phá các lựa chọn thay thế hoặc các ưu đãi cho các cam kết dài hạn.

- **PaperlessBilling Analysis:**
  PaperlessBilling không nhận được sự phản hồi tích cực từ khách hàng, điều này rõ ràng từ tỷ lệ churn đáng kể liên quan đến phương thức thanh toán này.

- **PaymentMethod Insights:**
  Electronic check là một vấn đề lớn, đóng góp vào 57,3% tỷ lệ churn. Việc giải quyết các vấn đề liên quan đến phương thức thanh toán này là rất quan trọng. Mailed check, Bank Transfer (tự động) và Credit Card (tự động) tiếp theo sau, yêu cầu sự chú ý để cải thiện trải nghiệm thanh toán tổng thể cho khách hàng.

Những phát hiện này cung cấp những thông tin có thể hành động để cải thiện các điều khoản hợp đồng, sở thích thanh toán và phương thức thanh toán nhằm nâng cao sự hài lòng và giữ chân khách hàng.

## Phân phối Các Đặc Trưng Số
Trong phân tích này, chúng ta sẽ khám phá sự phân phối của các đặc trưng số để hiểu rõ hơn về sự phân bố và đặc điểm của các thuộc tính định lượng trong bộ dữ liệu.
"""

fig, ax = plt.subplots(nrows = 1,ncols = 3,figsize = (15,5))
for i in range(len(numerical_features)):
    plt.subplot(1,3,i+1)
    sns.distplot(df1[numerical_features[i]],color = colors[0])
    title = 'Distribution : ' + numerical_features[i]
    plt.title(title)
plt.show()

"""- **Tenure Distribution:**
  Phân phối thời hạn hợp đồng thể hiện một mô hình hai đỉnh với các đỉnh ở khoảng 0-70, chỉ ra sự hiện diện của hai nhóm khách hàng khác nhau trong cơ sở dữ liệu.

- **MonthlyCharges Distribution:**
  Phân phối chi phí hàng tháng tạo ra một phân phối hai đỉnh với các đỉnh ở khoảng 20-80, gợi ý sự tồn tại của hai cấu trúc chi phí hoặc các mức dịch vụ phổ biến.

- **TotalCharges Distribution:**
  Phân phối tổng chi phí thể hiện sự phân phối lệch phải hoặc lệch dương, chỉ ra sự tập trung của các giá trị thấp với sự giảm dần về các giá trị cao hơn.

Những phân phối các đặc trưng số này cung cấp cái nhìn quý giá về các mẫu hình khác nhau trong thời gian sử dụng dịch vụ của khách hàng, chi phí hàng tháng và tổng chi phí. Hiểu rõ những phân phối này giúp tinh chỉnh các chiến lược phân khúc và gắn kết khách hàng.

## Biến Mục Tiêu Liên Quan đến Các Đặc Trưng Số
"""

ax = sns.kdeplot(df1.MonthlyCharges[(df1["Churn"] == 0) ],
                color="Red", shade = True);
ax = sns.kdeplot(df1.MonthlyCharges[(df1["Churn"] == 1) ],
                ax =ax, color="Black", shade= True);
ax.legend(["Not Churn","Churn"],loc='upper right');
ax.set_ylabel('Density');
ax.set_xlabel('Monthly Charges');
ax.set_title('Monthly Charges VS Churn Distribution');

"""Khách hàng có xu hướng rời bỏ dịch vụ nhiều hơn khi phải chịu các khoản chi phí hàng tháng cao."""

ax = sns.kdeplot(df1.TotalCharges[(df1["Churn"] == 0) ],
                color="red", shade = True);
ax = sns.kdeplot(df1.TotalCharges[(df1["Churn"] == 1) ],
                ax =ax, color="black", shade= True);
ax.legend(["Not Churn","Churn"],loc='upper right');
ax.set_ylabel('Density');
ax.set_xlabel('Total Charges');
ax.set_title('Total Charges VS Churn Distribution');

"""Quan sát cho thấy các khoản Chi Phí Tổng (Total Charges) cao liên quan đến khả năng churn cao của khách hàng, điều này gợi ý một vấn đề tiềm ẩn với hệ thống giá cả. Việc giải quyết và tối ưu hóa cấu trúc giá cả là rất quan trọng để giảm thiểu yếu tố này, giúp giảm tỷ lệ churn của khách hàng. Một cuộc khảo sát kỹ lưỡng và điều chỉnh chiến lược giá có thể giúp nâng cao sự hài lòng và giữ chân khách hàng."""

plt.figure(figsize = (30,5))
sns.countplot(x='tenure', data=df1, hue='Churn', palette = colors, edgecolor='black')
plt.title('Tenure VS Churn ')
plt.xlabel('Tenure')
plt.ylabel('Count')
plt.legend(['No Churn', 'Churn'], loc='upper right')
plt.show()

"""- **Tenure Analysis:**
  Một số lượng đáng kể khách hàng rời bỏ dịch vụ trong tháng đầu tiên, với tỷ lệ hủy dịch vụ cao tiếp tục kéo dài trong 4-5 tháng sau. Tuy nhiên, số lượng churn giảm dần khi thời gian sử dụng dịch vụ (tenure) tăng lên. Biểu đồ thể hiện một mô hình đối xứng, với phía bên trái chủ yếu là các số liệu churn cao, còn phía bên phải là các số liệu churn thấp. Điều này cho thấy mối tương quan giữa thời gian sử dụng dịch vụ lâu dài và khả năng churn thấp hơn. Việc hiểu và tận dụng xu hướng này có thể giúp xây dựng các chiến lược nâng cao khả năng giữ chân khách hàng theo thời gian.

## Các đặc trưng định tính so với các đặc trưng định lượng liên quan đến Biến Mục Tiêu (Churn)
"""

# Đặt palette tùy chỉnh cho hai giá trị của 'Churn'
colors = ['#1f77b4', '#ff7f0e']  # Ví dụ màu xanh dương cho 'No Churn' và cam cho 'Churn'

# Đảm bảo rằng có đủ số lượng subplots
a = 0
fig, ax = plt.subplots(nrows=3, ncols=1, figsize=(15, 15))
ax = ax.flatten()  # Đảm bảo 'ax' là mảng phẳng để dễ dàng truy cập

# Tạo các biểu đồ
for i in range(len(numerical_features)):
    for j in range(i + 1, len(numerical_features)):
        sns.scatterplot(
            x=numerical_features[i],
            y=numerical_features[j],
            data=df1,
            hue='Churn',
            palette=colors,
            edgecolor='black',
            ax=ax[a]
        )
        # Không sử dụng plt.legend() thủ công
        title = f"{numerical_features[i]} vs {numerical_features[j]}"
        ax[a].set_title(title)
        a += 1

plt.tight_layout()
plt.show()

"""- **Tenure and MonthlyCharges Relationship:**
  - Đối với thời gian sử dụng dịch vụ trong khoảng 0-20 tháng, churn khách hàng xảy ra ở nhiều giá trị MonthlyCharges khác nhau.
  - Từ 20-60 tháng, khách hàng có giá trị MonthlyCharges cao (70-120) có xu hướng có khả năng rời bỏ dịch vụ cao hơn.

- **TotalCharges vs Tenure:**
  - Khi tenure tăng lên, TotalCharges cũng tăng, cho thấy mối tương quan tích cực.
  - Khách hàng rời bỏ dịch vụ thường là những người có mức phí cao nhất trong khoảng thời gian sử dụng dịch vụ của họ, cùng với một số khách hàng có mức phí trung bình.

- **MonthlyCharges Threshold:**
  - Khách hàng có xu hướng quyết định hủy bỏ đăng ký khi MonthlyCharges đạt mức 70 trở lên.

Những thông tin này nhấn mạnh mối quan hệ tinh vi giữa tenure, MonthlyCharges và TotalCharges, cung cấp những thông tin quý giá để tối ưu hóa chiến lược giá cả và các nỗ lực giữ chân khách hàng.

## Giải Quyết Mất Cân Bằng Dữ Liệu Với SMOTE:

Trong việc xử lý các bộ dữ liệu mất cân bằng, hai chiến lược cơ bản được xem xét:

1. **Downsampling (Undersampling):** Giảm tỉ lệ của lớp đa số bằng cách cắt bớt các mẫu của lớp này.
   
2. **Upsampling (Oversampling):** Tăng cường sự hiện diện của lớp thiểu số bằng cách tăng số lượng mẫu của lớp này để phù hợp với lớp đa số.

Sau khi khám phá kỹ lưỡng cả hai phương pháp giảm mẫu và tăng mẫu, quyết định được đưa ra là chọn phương pháp tăng mẫu (oversampling).

Để đạt được sự cân bằng tối ưu trong dữ liệu, chúng tôi sẽ sử dụng thư viện imbalanced-learn (imblearn).
"""

cols = list(df1.columns)
cols.remove('Churn')

x = df1.loc[:,cols]
y = df1.loc[:,'Churn']


imputer = SimpleImputer(strategy='mean')
x = imputer.fit_transform(x)

over = SMOTE(sampling_strategy = 1)

x1,y1 = over.fit_resample(x,y)
print("Class distribution before SMOTE:", Counter(y))
print("Class distribution after SMOTE:", Counter(y1))

"""## Giải Quyết Vấn Đề Rò Rỉ Dữ Liệu Và Quy Trình Scale Dữ Liệu theo Phương Pháp Min-Max:
Rò rỉ dữ liệu là một thách thức lớn khi thông tin bên ngoài bộ dữ liệu huấn luyện ảnh hưởng đến quá trình xây dựng mô hình—một vấn đề thường bị bỏ qua.

Để phát triển các mô hình mạnh mẽ, việc giảm thiểu rò rỉ dữ liệu là điều cần thiết. Sự xuất hiện phổ biến của các mô hình quá lạc quan, gần như vô dụng trong sản xuất, nhấn mạnh tính cấp bách của vấn đề này.

Để bảo vệ khỏi rò rỉ dữ liệu, một phương pháp thận trọng là sử dụng train-test-split trước khi thực hiện bất kỳ phép biến đổi nào. Điều này đảm bảo rằng các phép biến đổi được áp dụng dựa trên dữ liệu huấn luyện, duy trì tính toàn vẹn cho cả dữ liệu huấn luyện và dữ liệu kiểm tra.

Việc scale dữ liệu là một bước quan trọng trong quá trình tiền xử lý dữ liệu, đặc biệt khi làm việc với các thuật toán học máy yêu cầu các đặc trưng có giá trị trong một phạm vi nhất định. Một trong những phương pháp phổ biến để scale dữ liệu là Min-Max Scaling.

Phương pháp Min-Max Scaling chuyển đổi các giá trị của từng đặc trưng về một phạm vi cụ thể, thường là từ 0 đến 1.
"""

x_train, x_test, y_train, y_test = train_test_split(x1, y1, test_size = 0.20, random_state = 2)
# Initialize MinMaxScaler
scaler = MinMaxScaler()

# Apply MinMaxScaler to the training and testing data
x_train = scaler.fit_transform(x_train)
x_test = scaler.transform(x_test)

"""## XGBoost"""

# 1. Huấn luyện mô hình XGBoost
# ---------------------------------------
xgboost_model = xgb.XGBClassifier(use_label_encoder=False, eval_metric='logloss')
xgboost_model.fit(x_train, y_train)

# Dự đoán và đánh giá mô hình XGBoost
xgboost_predictions = xgboost_model.predict(x_test)
print("XGBoost Model Accuracy:", accuracy_score(y_test, xgboost_predictions))
print("Classification Report:\n", classification_report(y_test, xgboost_predictions))

# Tạo ma trận nhầm lẫn
cm = confusion_matrix(y_test, xgboost_predictions)

# Vẽ biểu đồ ma trận nhầm lẫn
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=['No', 'Yes'], yticklabels=['No', 'Yes'])
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

# Tính toán giá trị ROC và AUC
fpr, tpr, thresholds = roc_curve(y_test, xgboost_model.predict_proba(x_test)[:, 1])
roc_auc = auc(fpr, tpr)

# Vẽ biểu đồ ROC
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='blue', label=f'ROC Curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve")
plt.legend(loc="lower right")
plt.show()

"""## ANN"""

# 2. Huấn luyện mô hình ANN
np.random.seed(42)
tf.random.set_seed(42)
random.seed(42)
# ---------------------------------------
ann_model = Sequential([
    Dense(64, input_dim=x_train.shape[1], activation='relu'),
    Dropout(0.5),
    Dense(32, activation='relu'),
    Dropout(0.5),
    Dense(1, activation='sigmoid')
])

ann_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
ann_model.fit(x_train, y_train, epochs=50, batch_size=32, validation_split=0.2)

# Đánh giá mô hình ANN
ann_loss, ann_accuracy = ann_model.evaluate(x_test, y_test)
print("ANN Model Accuracy:", ann_accuracy)

# Dự đoán nhị phân cho ANN và DNN (sử dụng ngưỡng 0.5)
ann_predictions = (ann_model.predict(x_test) > 0.5).astype("int32")

# Tạo bảng kết quả
print("Classification Report for ANN:\n", classification_report(y_test, ann_predictions))

# Tạo ma trận nhầm lẫn cho ANN
cm_ann = confusion_matrix(y_test, ann_predictions)
plt.figure(figsize=(8, 6))
sns.heatmap(cm_ann, annot=True, fmt="d", cmap="Blues", xticklabels=['No', 'Yes'], yticklabels=['No', 'Yes'])
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix for ANN")
plt.show()

# Tính toán ROC và AUC cho ANN
ann_fpr, ann_tpr, _ = roc_curve(y_test, ann_model.predict(x_test))
ann_roc_auc = auc(ann_fpr, ann_tpr)

# Vẽ ROC Curve cho ANN
plt.figure(figsize=(8, 6))
plt.plot(ann_fpr, ann_tpr, color='blue', label=f'ROC Curve for ANN (AUC = {ann_roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve for ANN")
plt.legend(loc="lower right")
plt.show()

"""## DNN"""

# 3. Huấn luyện mô hình DNN
np.random.seed(42)
tf.random.set_seed(42)
random.seed(42)
# ---------------------------------------
dnn_model = Sequential([
    Dense(128, input_dim=x_train.shape[1], activation='relu'),
    Dropout(0.4),
    Dense(64, activation='relu'),
    Dropout(0.4),
    Dense(32, activation='relu'),
    Dropout(0.4),
    Dense(1, activation='sigmoid')
])

dnn_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
dnn_model.fit(x_train, y_train, epochs=100, batch_size=32, validation_split=0.2)

# Đánh giá mô hình DNN
dnn_loss, dnn_accuracy = dnn_model.evaluate(x_test, y_test)
print("DNN Model Accuracy:", dnn_accuracy)

dnn_predictions = (dnn_model.predict(x_test) > 0.5).astype("int32")
print("Classification Report for DNN:\n", classification_report(y_test, dnn_predictions))

# Tạo ma trận nhầm lẫn cho DNN
cm_dnn = confusion_matrix(y_test, dnn_predictions)
plt.figure(figsize=(8, 6))
sns.heatmap(cm_dnn, annot=True, fmt="d", cmap="Blues", xticklabels=['No', 'Yes'], yticklabels=['No', 'Yes'])
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix for DNN")
plt.show()

# Tính toán ROC và AUC cho DNN
dnn_fpr, dnn_tpr, _ = roc_curve(y_test, dnn_model.predict(x_test))
dnn_roc_auc = auc(dnn_fpr, dnn_tpr)

# Vẽ ROC Curve cho DNN
plt.figure(figsize=(8, 6))
plt.plot(dnn_fpr, dnn_tpr, color='green', label=f'ROC Curve for DNN (AUC = {dnn_roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve for DNN")
plt.legend(loc="lower right")
plt.show()

"""## So Sánh Kết Quả"""

# Các hàm hỗ trợ để tính các chỉ số cho từng mô hình
def evaluate_model(model, x_train, x_test, y_train, y_test):
    # Dự đoán trên tập huấn luyện và tập kiểm tra
    y_train_pred = (model.predict(x_train) > 0.5).astype("int32") if model != xgboost_model else model.predict(x_train)
    y_test_pred = (model.predict(x_test) > 0.5).astype("int32") if model != xgboost_model else model.predict(x_test)

    # Tính các chỉ số trên tập huấn luyện
    train_accuracy = accuracy_score(y_train, y_train_pred)
    test_accuracy = accuracy_score(y_test, y_test_pred)
    precision = precision_score(y_test, y_test_pred)
    recall = recall_score(y_test, y_test_pred)
    f1 = f1_score(y_test, y_test_pred)
    auc = roc_auc_score(y_test, model.predict_proba(x_test)[:, 1]) if model != ann_model and model != dnn_model else roc_auc_score(y_test, model.predict(x_test))

    return train_accuracy, test_accuracy, precision, recall, f1, auc

# Tính các chỉ số cho từng mô hình
xgboost_scores = evaluate_model(xgboost_model, x_train, x_test, y_train, y_test)
ann_scores = evaluate_model(ann_model, x_train, x_test, y_train, y_test)
dnn_scores = evaluate_model(dnn_model, x_train, x_test, y_train, y_test)

# Tăng chiều rộng hiển thị của bảng để tránh xuống hàng
pd.set_option('display.max_columns', None)
pd.set_option('display.width', 1000)  # Tăng chiều rộng hiển thị
# Tạo DataFrame chứa các chỉ số cho từng mô hình
comparison_df = pd.DataFrame({
    "Model": ["XGBoost", "ANN", "DNN"],
    "Train Accuracy": [xgboost_scores[0], ann_scores[0], dnn_scores[0]],
    "Test Accuracy": [xgboost_scores[1], ann_scores[1], dnn_scores[1]],
    "Precision": [xgboost_scores[2], ann_scores[2], dnn_scores[2]],
    "Recall": [xgboost_scores[3], ann_scores[3], dnn_scores[3]],
    "F1 Score": [xgboost_scores[4], ann_scores[4], dnn_scores[4]],
    "AUC Score": [xgboost_scores[5], ann_scores[5], dnn_scores[5]]
})

# Sắp xếp bảng theo Test Accuracy theo thứ tự giảm dần
comparison_df = comparison_df.sort_values(by="Test Accuracy", ascending=False).reset_index(drop=True)

# Hiển thị bảng so sánh
comparison_df.head()

"""## Causal AI"""

# Giả sử data là DataFrame chứa dữ liệu của bạn
data_encoded = df1.copy()
# Định nghĩa mô hình nhân quả
causal_model = CausalModel(
    data=data_encoded,
    treatment="Contract",
    outcome="Churn",
    common_causes=["MonthlyCharges", "tenure", "SeniorCitizen", "Partner", "Dependents", "PhoneService", "InternetService", "PaperlessBilling", "PaymentMethod"]
)
# Hiển thị đồ thị nhân quả với bố cục mới
causal_model.view_model(layout="circo")

# Giả sử data là DataFrame chứa dữ liệu của bạn
data_encoded = df1.copy()
# Định nghĩa mô hình nhân quả
causal_model = CausalModel(
    data=data_encoded,
    treatment="Contract",
    outcome="Churn",
    common_causes=['DeviceProtection', 'MultipleLines', 'OnlineBackup', 'OnlineSecurity', 'StreamingMovies', 'StreamingTV', 'TechSupport', 'TotalCharges', 'gender']
)
# Hiển thị đồ thị nhân quả với bố cục mới
causal_model.view_model(layout="circo")  # Hoặc thử layout="neato" hoặc layout="twopi" để kiểm tra bố cục khác
identified_estimand = causal_model.identify_effect(proceed_when_unidentifiable=True,
                                 method_name="exhaustive-search")
print(identified_estimand)

estimate_lr = causal_model.estimate_effect(identified_estimand,method_name="backdoor.linear_regression",
                                     control_value = 0,
                                     treatment_value = 1,
                                 confidence_intervals=False,
                                method_params={"init_params":{'model_y':GradientBoostingClassifier(),
                                                              'model_t': GradientBoostingClassifier(),
                                                              "model_final":GradientBoostingClassifier()},
                                               "fit_params":{}})
print(estimate_lr)

res_random = causal_model.refute_estimate(identified_estimand, estimate_lr, method_name="random_common_cause")
print(res_random)

# Training and fitting a Random Forest Model
final_model = XGBClassifier(n_estimators=100,
                                  random_state=0).fit(x_train, y_train)

feature_names_list = [
    'gender', 'SeniorCitizen', 'Partner', 'Dependents', 'tenure', 'PhoneService',
    'MultipleLines', 'InternetService', 'OnlineSecurity', 'OnlineBackup',
    'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies',
    'Contract', 'PaperlessBilling', 'PaymentMethod', 'MonthlyCharges', 'TotalCharges']
x_test_df = pd.DataFrame(x_test, columns=feature_names_list)
perm = PermutationImportance(final_model, random_state=1).fit(x_test_df, y_test)
eli5.show_weights(perm, feature_names=x_test_df.columns.tolist())

# training and fitting a Decision Tree
from sklearn.tree import DecisionTreeClassifier
feature_names_list = [i for i in data.columns]
tree_model = DecisionTreeClassifier(random_state=0).fit(x_train, y_train)

feature_names_list

feature_names_list.remove("Churn")

# Tạo DataFrame từ x_train với tên các cột
x_train_df = pd.DataFrame(x_train, columns=feature_names_list)

# Xuất đồ thị cây quyết định dưới dạng chuỗi
tree_graph = tree.export_graphviz(
    tree_model,
    feature_names=x_train_df.columns.tolist(),
    filled=True,
    rounded=True,
    special_characters=True,
    out_file=None
)

# Tạo đối tượng Source và lưu dưới dạng PNG
graph = graphviz.Source(tree_graph)
output_path = "decision_tree.png"  # Đường dẫn lưu ảnh

# Lưu biểu đồ dưới dạng PNG
graph.format = "png"
graph.render(filename=output_path, cleanup=True)  # cleanup=True để xóa tệp tạm thời

print(f"Biểu đồ đã được lưu thành công tại: {output_path}")

plt.rcParams['figure.dpi'] = 500

# Visualising the decision tree
dt = DecisionTreeClassifier(max_depth = 3, random_state=10)

# fitting the decision tree model on the training set
dt.fit(x_train_df, y_train)

decision_tree = tree.export_graphviz(dt, out_file='tree.dot', feature_names=x_train_df.columns, filled=True, max_depth=3)

# converting the dot image to png format
!dot -Tpng tree.dot -o tree.png

#plotting the decision tree
image = plt.imread('tree.png')
plt.figure(figsize=(17,8))
plt.imshow(image);